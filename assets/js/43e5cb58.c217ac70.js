"use strict";(globalThis.webpackChunkk_3_s_docs=globalThis.webpackChunkk_3_s_docs||[]).push([[9270],{99220:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"networking/networking-services","title":"Networking Services","description":"This page explains how CoreDNS, Traefik Ingress controller, Network Policy controller, and ServiceLB load balancer controller work within K3s.","source":"@site/docs/networking/networking-services.md","sourceDirName":"networking","slug":"/networking/networking-services","permalink":"/networking/networking-services","draft":false,"unlisted":false,"editUrl":"https://github.com/k3s-io/docs/edit/main/docs/networking/networking-services.md","tags":[],"version":"current","lastUpdatedAt":1770234782000,"frontMatter":{"title":"Networking Services"},"sidebar":"mySidebar","previous":{"title":"Multus and IPAM plugins","permalink":"/networking/multus-ipams"},"next":{"title":"Advanced Options / Configuration","permalink":"/advanced"}}');var i=r(74848),s=r(28453);const t={title:"Networking Services"},l=void 0,a={},d=[{value:"CoreDNS",id:"coredns",level:2},{value:"Traefik Ingress Controller",id:"traefik-ingress-controller",level:2},{value:"Network Policy Controller",id:"network-policy-controller",level:2},{value:"Service Load Balancer",id:"service-load-balancer",level:2},{value:"How ServiceLB Works",id:"how-servicelb-works",level:3},{value:"Usage",id:"usage",level:3},{value:"Controlling ServiceLB Node Selection",id:"controlling-servicelb-node-selection",level:3},{value:"Creating ServiceLB Node Pools",id:"creating-servicelb-node-pools",level:3},{value:"Disabling ServiceLB",id:"disabling-servicelb",level:3},{value:"Deploying an External Cloud Controller Manager",id:"deploying-an-external-cloud-controller-manager",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"This page explains how CoreDNS, Traefik Ingress controller, Network Policy controller, and ServiceLB load balancer controller work within K3s."}),"\n",(0,i.jsxs)(n.p,{children:["Refer to the ",(0,i.jsx)(n.a,{href:"/networking/basic-network-options",children:"Installation Network Options"})," page for details on Flannel configuration options and backend selection, or how to set up your own CNI."]}),"\n",(0,i.jsxs)(n.p,{children:["For information on which ports need to be opened for K3s, refer to the ",(0,i.jsx)(n.a,{href:"/installation/requirements#networking",children:"Networking Requirements"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"coredns",children:"CoreDNS"}),"\n",(0,i.jsxs)(n.p,{children:["CoreDNS is deployed automatically on server startup. To disable it, configure all servers in the cluster with the ",(0,i.jsx)(n.code,{children:"--disable=coredns"})," option."]}),"\n",(0,i.jsx)(n.p,{children:"If you don't install CoreDNS, you will need to install a cluster DNS provider yourself."}),"\n",(0,i.jsx)(n.h2,{id:"traefik-ingress-controller",children:"Traefik Ingress Controller"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://traefik.io/",children:"Traefik"})," is a modern HTTP reverse proxy and load balancer made to deploy microservices with ease. It simplifies networking complexity while designing, deploying, and running applications."]}),"\n",(0,i.jsx)(n.p,{children:"The Traefik ingress controller deploys a LoadBalancer Service that uses ports 80 and 443, advertises the LoadBalancer Service's External IPs in the Status of Ingress resources it manages."}),"\n",(0,i.jsx)(n.p,{children:"By default, ServiceLB will use all nodes in the cluster to host the Traefik LoadBalancer Service, meaning ports 80 and 443 will not be usable for other HostPort or NodePort pods, and Ingress resources' Status will show all cluster members' node IPs."}),"\n",(0,i.jsxs)(n.p,{children:["To restrict the nodes used by Traefik, and by extension the node IPs advertised in the Ingress Status, you can follow the instructions in the ",(0,i.jsx)(n.a,{href:"#controlling-servicelb-node-selection",children:"Controlling ServiceLB Node Selection"})," section below to limit what nodes ServiceLB runs on, or by adding some nodes to a LoadBalancer pool and restricting the Traefik Service to that pool by setting matching labels in the Traefik HelmChartConfig."]}),"\n",(0,i.jsxs)(n.p,{children:["Traefik is deployed by default when starting the server. The default chart values can be found in ",(0,i.jsx)(n.code,{children:"/var/lib/rancher/k3s/server/manifests/traefik.yaml"}),", but this file should not be edited manually, as K3s will replace the file with defaults at startup.\nInstead, you should customize Traefik by creating an additional ",(0,i.jsx)(n.code,{children:"HelmChartConfig"})," manifest in ",(0,i.jsx)(n.code,{children:"/var/lib/rancher/k3s/server/manifests"}),".\nFor more details and an example see ",(0,i.jsx)(n.a,{href:"/add-ons/helm#customizing-packaged-components-with-helmchartconfig",children:"Customizing Packaged Components with HelmChartConfig"}),".\nFor more information on the possible configuration values, refer to ",(0,i.jsx)(n.code,{children:"values.yaml"})," of the ",(0,i.jsx)(n.a,{href:"https://github.com/k3s-io/k3s-charts/tree/main/charts/traefik",children:"Traefik Helm Chart"})," included with your version of K3s."]}),"\n",(0,i.jsxs)(n.p,{children:["To remove Traefik from your cluster, start all servers with the ",(0,i.jsx)(n.code,{children:"--disable=traefik"})," flag.\nFor more information, see ",(0,i.jsx)(n.a,{href:"/installation/packaged-components",children:"Managing Packaged Components"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For details on the specific version of Traefik included with K3s, consult the Release Notes for your version."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["K3s versions starting with ",(0,i.jsx)(n.strong,{children:"1.32"})," include Traefik v3. Existing installations of Traefik v2 will be automatically upgraded to v3 when K3s is upgraded.\nTraefik v3 should be compatible with configuration from v2; consult the upstream ",(0,i.jsx)(n.a,{href:"https://doc.traefik.io/traefik/migrate/v2-to-v3/",children:"v2 to v3 migration"})," docs for more information."]}),"\n",(0,i.jsxs)(n.li,{children:["K3s versions ",(0,i.jsx)(n.strong,{children:"1.21"})," through ",(0,i.jsx)(n.strong,{children:"1.31"})," included Traefik v2, unless an existing installation of Traefik v1 was found, in which case Traefik was not upgraded to v2."]}),"\n",(0,i.jsxs)(n.li,{children:["K3s versions ",(0,i.jsx)(n.strong,{children:"1.20"})," and ",(0,i.jsx)(n.strong,{children:"earlier"})," included Traefik v1."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"network-policy-controller",children:"Network Policy Controller"}),"\n",(0,i.jsxs)(n.p,{children:["K3s includes an embedded network policy controller. The underlying implementation is ",(0,i.jsx)(n.a,{href:"https://github.com/cloudnativelabs/kube-router",children:"kube-router's"})," netpol controller library (no other kube-router functionality is present) and can be found ",(0,i.jsx)(n.a,{href:"https://github.com/k3s-io/k3s/tree/main/pkg/agent/netpol",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To disable it, start each server with the ",(0,i.jsx)(n.code,{children:"--disable-network-policy"})," flag."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["Network policy iptables rules are not removed if the K3s configuration is changed to disable the network policy controller. To clean up the configured kube-router network policy rules after disabling the network policy controller, use the ",(0,i.jsx)(n.code,{children:"k3s-killall.sh"})," script, or clean them using ",(0,i.jsx)(n.code,{children:"iptables-save"})," and ",(0,i.jsx)(n.code,{children:"iptables-restore"}),". These steps must be run manually on all nodes in the cluster."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"iptables-save | grep -v KUBE-ROUTER | iptables-restore\nip6tables-save | grep -v KUBE-ROUTER | ip6tables-restore\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"service-load-balancer",children:"Service Load Balancer"}),"\n",(0,i.jsxs)(n.p,{children:["Any LoadBalancer controller can be deployed to your K3s cluster. By default, K3s provides a load balancer known as ",(0,i.jsx)(n.a,{href:"https://github.com/k3s-io/klipper-lb",children:"ServiceLB"})," (formerly Klipper LoadBalancer) that uses available host ports."]}),"\n",(0,i.jsxs)(n.p,{children:["Upstream Kubernetes allows Services of type LoadBalancer to be created, but doesn't include a default load balancer implementation, so these services will remain ",(0,i.jsx)(n.code,{children:"pending"})," until one is installed. Many hosted services require a cloud provider such as Amazon EC2 or Microsoft Azure to offer an external load balancer implementation. By contrast, the K3s ServiceLB makes it possible to use LoadBalancer Services without a cloud provider or any additional configuration."]}),"\n",(0,i.jsx)(n.h3,{id:"how-servicelb-works",children:"How ServiceLB Works"}),"\n",(0,i.jsxs)(n.p,{children:["The ServiceLB controller watches Kubernetes ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Services"})," with the ",(0,i.jsx)(n.code,{children:"spec.type"})," field set to ",(0,i.jsx)(n.code,{children:"LoadBalancer"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For each LoadBalancer Service, a ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",children:"DaemonSet"})," is created in the ",(0,i.jsx)(n.code,{children:"kube-system"})," namespace. This DaemonSet in turn creates ServiceLB Pods with a ",(0,i.jsx)(n.code,{children:"svc-"})," prefix, on each node. These pods leverage hostPort using the service port, hence they will only be deployed on nodes that have that port available. If there aren't any nodes with that port available, the LB will remain Pending. Note that it is possible to expose multiple Services on the same node, as long as they use different ports."]}),"\n",(0,i.jsxs)(n.p,{children:["When the ServiceLB Pod runs on a node that has an external IP configured, the node's external IP is populated into the Service's ",(0,i.jsx)(n.code,{children:"status.loadBalancer.ingress"})," address list with ",(0,i.jsx)(n.code,{children:"ipMode: VIP"}),". Otherwise, the node's internal IP is used."]}),"\n",(0,i.jsxs)(n.p,{children:["If the traffic to the external IP is subject to ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Network_address_translation",children:"Network Address Translation (NAT)"})," - for example in public clouds when using the public IP of the node as external IP - the traffic is routed into the ServiceLB pod via the hostPort. The pod then uses iptables to forward traffic to the Service's ClusterIP address and port. If the traffic is not subject to NAT and instead arrives with destination address matching the LoadBalancer address, traffic is intercepted (normally by kube-proxy iptables chains or ipvs) and forwarded to the Service's ClusterIP address and port."]}),"\n",(0,i.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(n.p,{children:["Create a ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer",children:"Service of type LoadBalancer"})," in K3s."]}),"\n",(0,i.jsx)(n.admonition,{title:"Known Issue",type:"warning",children:(0,i.jsxs)(n.p,{children:["If external traffic reaches the node using a NAT (e.g. in public clouds) and you require ",(0,i.jsx)(n.code,{children:"externalTrafficPolicy=local"})," for purposes such as client source IP preservation, please do not define the k3s config ",(0,i.jsx)(n.code,{children:"node-external-ip"})," for any of the nodes, as that will not work correctly"]})}),"\n",(0,i.jsx)(n.h3,{id:"controlling-servicelb-node-selection",children:"Controlling ServiceLB Node Selection"}),"\n",(0,i.jsxs)(n.p,{children:["Adding the ",(0,i.jsx)(n.code,{children:"svccontroller.k3s.cattle.io/enablelb=true"})," label to one or more nodes switches the ServiceLB controller into allow-list mode, where only nodes with the label are eligible to host LoadBalancer pods. Nodes that remain unlabeled will be excluded from use by ServiceLB."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"By default, nodes are not labeled. As long as all nodes remain unlabeled, all nodes with ports available will be used by ServiceLB."})}),"\n",(0,i.jsx)(n.h3,{id:"creating-servicelb-node-pools",children:"Creating ServiceLB Node Pools"}),"\n",(0,i.jsxs)(n.p,{children:["To select a particular subset of nodes to host pods for a LoadBalancer, add the ",(0,i.jsx)(n.code,{children:"enablelb"})," label to the desired nodes, and set matching ",(0,i.jsx)(n.code,{children:"lbpool"})," label values on the Nodes and Services. For example:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Label Node A and Node B with ",(0,i.jsx)(n.code,{children:"svccontroller.k3s.cattle.io/lbpool=pool1"})," and ",(0,i.jsx)(n.code,{children:"svccontroller.k3s.cattle.io/enablelb=true"})]}),"\n",(0,i.jsxs)(n.li,{children:["Label Node C and Node D with ",(0,i.jsx)(n.code,{children:"svccontroller.k3s.cattle.io/lbpool=pool2"})," and ",(0,i.jsx)(n.code,{children:"svccontroller.k3s.cattle.io/enablelb=true"})]}),"\n",(0,i.jsxs)(n.li,{children:["Create one LoadBalancer Service on port 443 with label ",(0,i.jsx)(n.code,{children:"svccontroller.k3s.cattle.io/lbpool=pool1"}),". The DaemonSet for this service only deploy Pods to Node A and Node B."]}),"\n",(0,i.jsxs)(n.li,{children:["Create another LoadBalancer Service on port 443 with label ",(0,i.jsx)(n.code,{children:"svccontroller.k3s.cattle.io/lbpool=pool2"}),". The DaemonSet will only deploy Pods to Node C and Node D."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"disabling-servicelb",children:"Disabling ServiceLB"}),"\n",(0,i.jsxs)(n.p,{children:["To disable ServiceLB, configure all servers in the cluster with the ",(0,i.jsx)(n.code,{children:"--disable=servicelb"})," flag."]}),"\n",(0,i.jsx)(n.p,{children:"This is necessary if you wish to run a different LB, such as MetalLB."}),"\n",(0,i.jsx)(n.h2,{id:"deploying-an-external-cloud-controller-manager",children:"Deploying an External Cloud Controller Manager"}),"\n",(0,i.jsx)(n.p,{children:"K3s provides an embedded Cloud Controller Manager (CCM) that does the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Hosts the ",(0,i.jsx)(n.a,{href:"#service-load-balancer",children:"ServiceLB"})," LoadBalancer controller."]}),"\n",(0,i.jsxs)(n.li,{children:["Clears the ",(0,i.jsx)(n.code,{children:"node.cloudprovider.kubernetes.io/uninitialized"})," taint."]}),"\n",(0,i.jsxs)(n.li,{children:["Sets node address fields based on the ",(0,i.jsx)(n.code,{children:"--node-ip"}),", ",(0,i.jsx)(n.code,{children:"--node-external-ip"}),", ",(0,i.jsx)(n.code,{children:"--node-internal-dns"}),", and ",(0,i.jsx)(n.code,{children:"--node-external-dns"})," flags."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Before deploying an external CCM, you must start all K3s servers with the ",(0,i.jsx)(n.code,{children:"--disable-cloud-controller"})," flag to disable the embedded CCM. When using an external CCM, node addresses will be provided by cloud provider instance metadata APIs, instead of the K3s flag values."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["If you disable the built-in CCM and set ",(0,i.jsx)(n.code,{children:"--kubelet-arg=cloud-provider=external"})," without deploying and properly configuring an external substitute, nodes will remain tainted and unschedulable. By default, disabling the built-in CCM prevents K3s from setting the kubelet ",(0,i.jsx)(n.code,{children:"cloud-provider"})," arg, which indicates that no cloud provider is in use. Without any cloud-provider, Node Provider-IDs and External Addresses will not be set."]})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var o=r(96540);const i={},s=o.createContext(i);function t(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);