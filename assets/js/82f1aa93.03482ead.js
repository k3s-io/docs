"use strict";(self.webpackChunkk_3_s_docs=self.webpackChunkk_3_s_docs||[]).push([[709],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,k=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(k,s(s({ref:t},u),{},{components:n})):a.createElement(k,s({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1199:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),s=["components"],o={title:"CIS Hardening Guide",weight:80},l=void 0,c={unversionedId:"security/hardening-guide",id:"security/hardening-guide",title:"CIS Hardening Guide",description:"This document provides prescriptive guidance for hardening a production installation of K3s. It outlines the configurations and controls required to address Kubernetes benchmark controls from the Center for Internet Security (CIS).",source:"@site/docs/security/hardening-guide.md",sourceDirName:"security",slug:"/security/hardening-guide",permalink:"/security/hardening-guide",draft:!1,editUrl:"https://github.com/k3s-io/k3s/docs/edit/main/docs/security/hardening-guide.md",tags:[],version:"current",lastUpdatedAt:1657220395,formattedLastUpdatedAt:"7/7/2022",frontMatter:{title:"CIS Hardening Guide",weight:80},sidebar:"mySidebar",previous:{title:"Secrets Encryption",permalink:"/security/secrets-encryption"},next:{title:"CIS Self Assessment Guide",permalink:"/security/self-assessment"}},u={},p=[{value:"Host-level Requirements",id:"host-level-requirements",level:2},{value:"Ensure <code>protect-kernel-defaults</code> is set",id:"ensure-protect-kernel-defaults-is-set",level:3},{value:"Set kernel parameters",id:"set-kernel-parameters",level:4},{value:"Kubernetes Runtime Requirements",id:"kubernetes-runtime-requirements",level:2},{value:"Pod Security Policies",id:"pod-security-policies",level:3},{value:"NetworkPolicies",id:"networkpolicies",level:3},{value:"API Server audit configuration",id:"api-server-audit-configuration",level:3},{value:"Known Issues",id:"known-issues",level:2},{value:"Control 1.2.15",id:"control-1215",level:3},{value:"Control 1.2.16",id:"control-1216",level:3},{value:"Control 1.2.22",id:"control-1222",level:3},{value:"Control 1.2.23",id:"control-1223",level:3},{value:"Control 1.2.24",id:"control-1224",level:3},{value:"Control 1.2.25",id:"control-1225",level:3},{value:"Control 1.2.26",id:"control-1226",level:3},{value:"Control 1.2.27",id:"control-1227",level:3},{value:"Control 1.2.33",id:"control-1233",level:3},{value:"Control 1.2.34",id:"control-1234",level:3},{value:"Control 1.3.1",id:"control-131",level:3},{value:"Control 3.2.1",id:"control-321",level:3},{value:"Control 4.2.7",id:"control-427",level:3},{value:"Control 5.1.5",id:"control-515",level:3},{value:"Control Plane Execution and Arguments",id:"control-plane-execution-and-arguments",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This document provides prescriptive guidance for hardening a production installation of K3s. It outlines the configurations and controls required to address Kubernetes benchmark controls from the Center for Internet Security (CIS)."),(0,i.kt)("p",null,"K3s has a number of security mitigations applied and turned on by default and will pass a number of the Kubernetes CIS controls without modification. There are some notable exceptions to this that require manual intervention to fully comply with the CIS Benchmark:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"K3s will not modify the host operating system. Any host-level modifications will need to be done manually."),(0,i.kt)("li",{parentName:"ol"},"Certain CIS policy controls for ",(0,i.kt)("inlineCode",{parentName:"li"},"PodSecurityPolicies")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"NetworkPolicies")," will restrict the functionality of the cluster. You must opt into having K3s configure these by adding the appropriate options (enabling of admission plugins) to your command-line flags or configuration file as well as manually applying appropriate policies. Further details are presented in the sections below.")),(0,i.kt)("p",null,"The first section (1.1) of the CIS Benchmark concerns itself primarily with pod manifest permissions and ownership. K3s doesn't utilize these for the core components since everything is packaged into a single binary."),(0,i.kt)("h2",{id:"host-level-requirements"},"Host-level Requirements"),(0,i.kt)("p",null,"There are two areas of host-level requirements: kernel parameters and etcd process/directory configuration. These are outlined in this section."),(0,i.kt)("h3",{id:"ensure-protect-kernel-defaults-is-set"},"Ensure ",(0,i.kt)("inlineCode",{parentName:"h3"},"protect-kernel-defaults")," is set"),(0,i.kt)("p",null,"This is a kubelet flag that will cause the kubelet to exit if the required kernel parameters are unset or are set to values that are different from the kubelet's defaults."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"protect-kernel-defaults")," is exposed as a top-level flag for K3s.")),(0,i.kt)("h4",{id:"set-kernel-parameters"},"Set kernel parameters"),(0,i.kt)("p",null,"Create a file called ",(0,i.kt)("inlineCode",{parentName:"p"},"/etc/sysctl.d/90-kubelet.conf")," and add the snippet below. Then run ",(0,i.kt)("inlineCode",{parentName:"p"},"sysctl -p /etc/sysctl.d/90-kubelet.conf"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"vm.panic_on_oom=0\nvm.overcommit_memory=1\nkernel.panic=10\nkernel.panic_on_oops=1\nkernel.keys.root_maxbytes=25000000\n")),(0,i.kt)("h2",{id:"kubernetes-runtime-requirements"},"Kubernetes Runtime Requirements"),(0,i.kt)("p",null,"The runtime requirements to comply with the CIS Benchmark are centered around pod security (PSPs), network policies and API Server auditing logs. These are outlined in this section. K3s doesn't apply any default PSPs or network policies. However, K3s ships with a controller that is meant to apply a given set of network policies. By default, K3s runs with the ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRestriction")," admission controller. To enable PSPs, add the following to the K3s start command: ",(0,i.kt)("inlineCode",{parentName:"p"},'--kube-apiserver-arg="enable-admission-plugins=NodeRestriction,PodSecurityPolicy,ServiceAccount"'),". This will have the effect of maintaining the ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeRestriction")," plugin as well as enabling the ",(0,i.kt)("inlineCode",{parentName:"p"},"PodSecurityPolicy"),". The same happens with the API Server auditing logs, K3s doesn't enable them by default, so audit log configuration and audit policy must be created manually."),(0,i.kt)("h3",{id:"pod-security-policies"},"Pod Security Policies"),(0,i.kt)("p",null,"When PSPs are enabled, a policy can be applied to satisfy the necessary controls described in section 5.2 of the CIS Benchmark."),(0,i.kt)("p",null,"Here is an example of a compliant PSP."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted-psp\nspec:\n  privileged: false                # CIS - 5.2.1\n  allowPrivilegeEscalation: false  # CIS - 5.2.5\n  requiredDropCapabilities:        # CIS - 5.2.7/8/9\n    - ALL\n  volumes:\n    - 'configMap'\n    - 'emptyDir'\n    - 'projected'\n    - 'secret'\n    - 'downwardAPI'\n    - 'csi'\n    - 'persistentVolumeClaim'\n    - 'ephemeral'\n  hostNetwork: false               # CIS - 5.2.4\n  hostIPC: false                   # CIS - 5.2.3\n  hostPID: false                   # CIS - 5.2.2\n  runAsUser:\n    rule: 'MustRunAsNonRoot'       # CIS - 5.2.6\n  seLinux:\n    rule: 'RunAsAny'\n  supplementalGroups:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  fsGroup:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  readOnlyRootFilesystem: false\n")),(0,i.kt)("p",null,'For the above PSP to be effective, we need to create a ClusterRole and a ClusterRoleBinding. We also need to include a "system unrestricted policy" which is needed for system-level pods that require additional privileges.'),(0,i.kt)("p",null,"These can be combined with the PSP yaml above and NetworkPolicy yaml below into a single file and placed in the ",(0,i.kt)("inlineCode",{parentName:"p"},"/var/lib/rancher/k3s/server/manifests")," directory. Below is an example of a ",(0,i.kt)("inlineCode",{parentName:"p"},"policy.yaml")," file. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted-psp\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  requiredDropCapabilities:\n    - ALL\n  volumes:\n    - 'configMap'\n    - 'emptyDir'\n    - 'projected'\n    - 'secret'\n    - 'downwardAPI'\n    - 'csi'\n    - 'persistentVolumeClaim'\n    - 'ephemeral'\n  hostNetwork: false\n  hostIPC: false\n  hostPID: false\n  runAsUser:\n    rule: 'MustRunAsNonRoot'\n  seLinux:\n    rule: 'RunAsAny'\n  supplementalGroups:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  fsGroup:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  readOnlyRootFilesystem: false\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: psp:restricted-psp\n  labels:\n    addonmanager.kubernetes.io/mode: EnsureExists\nrules:\n- apiGroups: ['extensions']\n  resources: ['podsecuritypolicies']\n  verbs:     ['use']\n  resourceNames:\n  - restricted-psp\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: default:restricted-psp\n  labels:\n    addonmanager.kubernetes.io/mode: EnsureExists\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: psp:restricted-psp\nsubjects:\n- kind: Group\n  name: system:authenticated\n  apiGroup: rbac.authorization.k8s.io\n---\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: system-unrestricted-psp\nspec:\n  allowPrivilegeEscalation: true\n  allowedCapabilities:\n  - '*'\n  fsGroup:\n    rule: RunAsAny\n  hostIPC: true\n  hostNetwork: true\n  hostPID: true\n  hostPorts:\n  - max: 65535\n    min: 0\n  privileged: true\n  runAsUser:\n    rule: RunAsAny\n  seLinux:\n    rule: RunAsAny\n  supplementalGroups:\n    rule: RunAsAny\n  volumes:\n  - '*'\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: system-unrestricted-node-psp-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system-unrestricted-psp-role\nsubjects:\n- apiGroup: rbac.authorization.k8s.io\n  kind: Group\n  name: system:nodes\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: system-unrestricted-psp-role\nrules:\n- apiGroups:\n  - policy\n  resourceNames:\n  - system-unrestricted-psp\n  resources:\n  - podsecuritypolicies\n  verbs:\n  - use\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: system-unrestricted-svc-acct-psp-rolebinding\n  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system-unrestricted-psp-role\nsubjects:\n- apiGroup: rbac.authorization.k8s.io\n  kind: Group\n  name: system:serviceaccounts\n---\nkind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: intra-namespace\n  namespace: kube-system\nspec:\n  podSelector: {}\n  ingress:\n    - from:\n      - namespaceSelector:\n          matchLabels:\n            name: kube-system\n---\nkind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: intra-namespace\n  namespace: default\nspec:\n  podSelector: {}\n  ingress:\n    - from:\n      - namespaceSelector:\n          matchLabels:\n            name: default\n---\nkind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: intra-namespace\n  namespace: kube-public\nspec:\n  podSelector: {}\n  ingress:\n    - from:\n      - namespaceSelector:\n          matchLabels:\n            name: kube-public\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note:")," The Kubernetes critical additions such as CNI, DNS, and Ingress are ran as pods in the ",(0,i.kt)("inlineCode",{parentName:"p"},"kube-system")," namespace. Therefore, this namespace will have a policy that is less restrictive so that these components can run properly.")),(0,i.kt)("h3",{id:"networkpolicies"},"NetworkPolicies"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"NOTE: K3s deploys kube-router for network policy enforcement. Support for this in K3s is currently experimental.")),(0,i.kt)("p",null,"CIS requires that all namespaces have a network policy applied that reasonably limits traffic into namespaces and pods."),(0,i.kt)("p",null,"Here is an example of a compliant network policy."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"kind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: intra-namespace\n  namespace: kube-system\nspec:\n  podSelector: {}\n  ingress:\n    - from:\n      - namespaceSelector:\n          matchLabels:\n            name: kube-system\n")),(0,i.kt)("p",null,"With the applied restrictions, DNS will be blocked unless purposely allowed. Below is a network policy that will allow for traffic to exist for DNS."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-network-dns-policy\n  namespace: <NAMESPACE>\nspec:\n  ingress:\n  - ports:\n    - port: 53\n      protocol: TCP\n    - port: 53\n      protocol: UDP\n  podSelector:\n    matchLabels:\n      k8s-app: kube-dns\n  policyTypes:\n  - Ingress\n")),(0,i.kt)("p",null,"The metrics-server and Traefik ingress controller will be blocked by default if network policies are not created to allow access. Traefik v1 as packaged in K3s version 1.20 and below uses different labels than Traefik v2. Ensure that you only use the sample yaml below that is associated with the version of Traefik present on your cluster."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-all-metrics-server\n  namespace: kube-system\nspec:\n  podSelector:\n    matchLabels:\n      k8s-app: metrics-server\n  ingress:\n  - {}\n  policyTypes:\n  - Ingress\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-all-svclbtraefik-ingress\n  namespace: kube-system\nspec:\n  podSelector: \n    matchLabels:\n      app: svclb-traefik\n  ingress:\n  - {}\n  policyTypes:\n  - Ingress\n---\n# Below is for 1.20 ONLY -- remove if on 1.21 or above\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-all-traefik-v120-ingress\n  namespace: kube-system\nspec:\n  podSelector:\n    matchLabels:\n      app: traefik\n  ingress:\n  - {}\n  policyTypes:\n  - Ingress\n---\n# Below is for 1.21 and above ONLY -- remove if on 1.20 or below\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-all-traefik-v121-ingress\n  namespace: kube-system\nspec:\n  podSelector:\n    matchLabels:\n      app.kubernetes.io/name: traefik\n  ingress:\n  - {}\n  policyTypes:\n  - Ingress\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note:")," Operators must manage network policies as normal for additional namespaces that are created.")),(0,i.kt)("h3",{id:"api-server-audit-configuration"},"API Server audit configuration"),(0,i.kt)("p",null,"CIS requirements 1.2.22 to 1.2.25 are related to configuring audit logs for the API Server. K3s doesn't create by default the log directory and audit policy, as auditing requirements are specific to each user's policies and environment."),(0,i.kt)("p",null,"The log directory, ideally, must be created before starting K3s. A restrictive access permission is recommended to avoid leaking potential sensitive information."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"sudo mkdir -p -m 700 /var/lib/rancher/k3s/server/logs\n")),(0,i.kt)("p",null,"A starter audit policy to log request metadata is provided below. The policy should be written to a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"audit.yaml")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"/var/lib/rancher/k3s/server")," directory. Detailed information about policy configuration for the API server can be found in the Kubernetes ",(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/debug-application-cluster/audit/"},"documentation"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n- level: Metadata\n")),(0,i.kt)("p",null,"Both configurations must be passed as arguments to the API Server as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"--kube-apiserver-arg='audit-log-path=/var/lib/rancher/k3s/server/logs/audit.log'\n--kube-apiserver-arg='audit-policy-file=/var/lib/rancher/k3s/server/audit.yaml'\n")),(0,i.kt)("p",null,"If the configurations are created after K3s is installed, they must be added to K3s' systemd service in ",(0,i.kt)("inlineCode",{parentName:"p"},"/etc/systemd/system/k3s.service"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ExecStart=/usr/local/bin/k3s \\\n    server \\\n    '--kube-apiserver-arg=audit-log-path=/var/lib/rancher/k3s/server/logs/audit.log' \\\n    '--kube-apiserver-arg=audit-policy-file=/var/lib/rancher/k3s/server/audit.yaml' \\\n")),(0,i.kt)("p",null,"K3s must be restarted to load the new configuration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"sudo systemctl daemon-reload\nsudo systemctl restart k3s.service\n")),(0,i.kt)("p",null,"Additional information about CIS requirements 1.2.22 to 1.2.25 is presented below."),(0,i.kt)("h2",{id:"known-issues"},"Known Issues"),(0,i.kt)("p",null,"The following are controls that K3s currently does not pass by default. Each gap will be explained, along with a note clarifying whether it can be passed through manual operator intervention, or if it will be addressed in a future release of K3s."),(0,i.kt)("h3",{id:"control-1215"},"Control 1.2.15"),(0,i.kt)("p",null,"Ensure that the admission control plugin ",(0,i.kt)("inlineCode",{parentName:"p"},"NamespaceLifecycle")," is set."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Setting admission control policy to `NamespaceLifecycle` ensures that objects cannot be created in non-existent namespaces, and that namespaces undergoing termination are not used for creating the new objects. This is recommended to enforce the integrity of the namespace termination process and also for the availability of the newer objects.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"enable-admission-plugins=")," and pass that to  ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-1216"},"Control 1.2.16"),(0,i.kt)("p",null,"Ensure that the admission control plugin ",(0,i.kt)("inlineCode",{parentName:"p"},"PodSecurityPolicy")," is set."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"A Pod Security Policy is a cluster-level resource that controls the actions that a pod can perform and what it has the ability to access. The `PodSecurityPolicy` objects define a set of conditions that a pod must run with in order to be accepted into the system. Pod Security Policies are comprised of settings and strategies that control the security features a pod has access to and hence this must be used to control pod access permissions.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"enable-admission-plugins=")," and pass that to  ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-1222"},"Control 1.2.22"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--audit-log-path")," argument is set."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Auditing the Kubernetes API Server provides a security-relevant chronological set of records documenting the sequence of activities that have affected system by individual users, administrators or other components of the system. Even though currently, Kubernetes provides only basic audit capabilities, it should be enabled. You can enable it by setting an appropriate audit log path.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-1223"},"Control 1.2.23"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--audit-log-maxage")," argument is set to 30 or as appropriate."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Retaining logs for at least 30 days ensures that you can go back in time and investigate or correlate any events. Set your audit log retention period to 30 days or as per your business requirements.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-1224"},"Control 1.2.24"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--audit-log-maxbackup")," argument is set to 10 or as appropriate."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Kubernetes automatically rotates the log files. Retaining old log files ensures that you would have sufficient log data available for carrying out any investigation or correlation. For example, if you have set file size of 100 MB and the number of old log files to keep as 10, you would approximate have 1 GB of log data that you could potentially use for your analysis.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-1225"},"Control 1.2.25"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--audit-log-maxsize")," argument is set to 100 or as appropriate."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Kubernetes automatically rotates the log files. Retaining old log files ensures that you would have sufficient log data available for carrying out any investigation or correlation. If you have set file size of 100 MB and the number of old log files to keep as 10, you would approximate have 1 GB of log data that you could potentially use for your analysis.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-1226"},"Control 1.2.26"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--request-timeout")," argument is set as appropriate."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Setting global request timeout allows extending the API server request timeout limit to a duration appropriate to the user's connection speed. By default, it is set to 60 seconds which might be problematic on slower connections making cluster resources inaccessible once the data volume for requests exceeds what can be transmitted in 60 seconds. But, setting this timeout limit to be too large can exhaust the API server resources making it prone to Denial-of-Service attack. Hence, it is recommended to set this limit as appropriate and change the default limit of 60 seconds only if needed.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-1227"},"Control 1.2.27"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--service-account-lookup")," argument is set to true."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"If `--service-account-lookup` is not enabled, the apiserver only verifies that the authentication token is valid, and does not validate that the service account token mentioned in the request is actually present in etcd. This allows using a service account token even after the corresponding service account is deleted. This is an example of time of check to time of use security issue.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-1233"},"Control 1.2.33"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--encryption-provider-config")," argument is set as appropriate."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"`etcd` is a highly available key-value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should be encrypted at rest to avoid any disclosures.",(0,i.kt)("p",null,"Detailed steps on how to configure secrets encryption in K3s are available in ",(0,i.kt)("a",{parentName:"p",href:"/security/secrets-encryption"},"Secrets Encryption"),".")),(0,i.kt)("h3",{id:"control-1234"},"Control 1.2.34"),(0,i.kt)("p",null,"Ensure that encryption providers are appropriately configured."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Where `etcd` encryption is used, it is important to ensure that the appropriate set of encryption providers is used. Currently, the `aescbc`, `kms` and `secretbox` are likely to be appropriate options.",(0,i.kt)("p",null,"This can be remediated by passing a valid configuration to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s")," as outlined above. Detailed steps on how to configure secrets encryption in K3s are available in ",(0,i.kt)("a",{parentName:"p",href:"/security/secrets-encryption"},"Secrets Encryption"),".")),(0,i.kt)("h3",{id:"control-131"},"Control 1.3.1"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--terminated-pod-gc-threshold")," argument is set as appropriate."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Garbage collection is important to ensure sufficient resource availability and avoiding degraded performance and availability. In the worst case, the system might crash or just be unusable for a long period of time. The current setting for garbage collection is 12,500 terminated pods which might be too high for your system to sustain. Based on your system resources and tests, choose an appropriate threshold value to activate garbage collection.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-321"},"Control 3.2.1"),(0,i.kt)("p",null,"Ensure that a minimal audit policy is created."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Logging is an important detective control for all systems, to detect potential unauthorized access.",(0,i.kt)("p",null,"This can be remediated by passing controls 1.2.22 - 1.2.25 and verifying their efficacy.")),(0,i.kt)("h3",{id:"control-427"},"Control 4.2.7"),(0,i.kt)("p",null,"Ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--make-iptables-util-chains")," argument is set to true."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Kubelets can automatically manage the required changes to iptables based on how you choose your networking options for the pods. It is recommended to let kubelets manage the changes to iptables. This ensures that the iptables configuration remains in sync with pods networking configuration. Manually configuring iptables with dynamic pod network configuration changes might hamper the communication between pods/containers and to the outside world. You might have iptables rules too restrictive or too open.",(0,i.kt)("p",null,"This can be remediated by passing this argument as a value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"--kube-apiserver-arg=")," argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"k3s server"),". An example can be found below.")),(0,i.kt)("h3",{id:"control-515"},"Control 5.1.5"),(0,i.kt)("p",null,"Ensure that default service accounts are not actively used"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rationale"),"Kubernetes provides a `default` service account which is used by cluster workloads where no specific service account is assigned to the pod.",(0,i.kt)("p",null,"Where access to the Kubernetes API from a pod is required, a specific service account should be created for that pod, and rights granted to that service account."),(0,i.kt)("p",null,"The default service account should be configured such that it does not provide a service account token and does not have any explicit rights assignments."),(0,i.kt)("p",null,"This can be remediated by updating the ",(0,i.kt)("inlineCode",{parentName:"p"},"automountServiceAccountToken")," field to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," service account in each namespace."),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," service accounts in the built-in namespaces (",(0,i.kt)("inlineCode",{parentName:"p"},"kube-system"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"kube-public"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"kube-node-lease"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"default"),"), K3s does not automatically do this. You can manually update this field on these service accounts to pass the control.")),(0,i.kt)("h2",{id:"control-plane-execution-and-arguments"},"Control Plane Execution and Arguments"),(0,i.kt)("p",null,"Listed below are the K3s control plane components and the arguments they are given at start, by default. Commented to their right is the CIS 1.6 control that they satisfy."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kube-apiserver \n    --advertise-port=6443 \n    --allow-privileged=true \n    --anonymous-auth=false                                                            # 1.2.1\n    --api-audiences=unknown \n    --authorization-mode=Node,RBAC \n    --bind-address=127.0.0.1 \n    --cert-dir=/var/lib/rancher/k3s/server/tls/temporary-certs\n    --client-ca-file=/var/lib/rancher/k3s/server/tls/client-ca.crt                    # 1.2.31\n    --enable-admission-plugins=NodeRestriction,PodSecurityPolicy                      # 1.2.17\n    --etcd-cafile=/var/lib/rancher/k3s/server/tls/etcd/server-ca.crt                  # 1.2.32\n    --etcd-certfile=/var/lib/rancher/k3s/server/tls/etcd/client.crt                   # 1.2.29\n    --etcd-keyfile=/var/lib/rancher/k3s/server/tls/etcd/client.key                    # 1.2.29\n    --etcd-servers=https://127.0.0.1:2379 \n    --insecure-port=0                                                                 # 1.2.19\n    --kubelet-certificate-authority=/var/lib/rancher/k3s/server/tls/server-ca.crt \n    --kubelet-client-certificate=/var/lib/rancher/k3s/server/tls/client-kube-apiserver.crt \n    --kubelet-client-key=/var/lib/rancher/k3s/server/tls/client-kube-apiserver.key \n    --profiling=false                                                                 # 1.2.21\n    --proxy-client-cert-file=/var/lib/rancher/k3s/server/tls/client-auth-proxy.crt \n    --proxy-client-key-file=/var/lib/rancher/k3s/server/tls/client-auth-proxy.key \n    --requestheader-allowed-names=system:auth-proxy \n    --requestheader-client-ca-file=/var/lib/rancher/k3s/server/tls/request-header-ca.crt \n    --requestheader-extra-headers-prefix=X-Remote-Extra- \n    --requestheader-group-headers=X-Remote-Group \n    --requestheader-username-headers=X-Remote-User \n    --secure-port=6444                                                                # 1.2.20\n    --service-account-issuer=k3s \n    --service-account-key-file=/var/lib/rancher/k3s/server/tls/service.key            # 1.2.28\n    --service-account-signing-key-file=/var/lib/rancher/k3s/server/tls/service.key \n    --service-cluster-ip-range=10.43.0.0/16 \n    --storage-backend=etcd3 \n    --tls-cert-file=/var/lib/rancher/k3s/server/tls/serving-kube-apiserver.crt        # 1.2.30\n    --tls-private-key-file=/var/lib/rancher/k3s/server/tls/serving-kube-apiserver.key # 1.2.30\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kube-controller-manager \n    --address=127.0.0.1 \n    --allocate-node-cidrs=true \n    --bind-address=127.0.0.1                                                       # 1.3.7\n    --cluster-cidr=10.42.0.0/16 \n    --cluster-signing-cert-file=/var/lib/rancher/k3s/server/tls/client-ca.crt \n    --cluster-signing-key-file=/var/lib/rancher/k3s/server/tls/client-ca.key \n    --kubeconfig=/var/lib/rancher/k3s/server/cred/controller.kubeconfig \n    --port=10252 \n    --profiling=false                                                              # 1.3.2\n    --root-ca-file=/var/lib/rancher/k3s/server/tls/server-ca.crt                   # 1.3.5\n    --secure-port=0 \n    --service-account-private-key-file=/var/lib/rancher/k3s/server/tls/service.key # 1.3.4 \n    --use-service-account-credentials=true                                         # 1.3.3\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kube-scheduler \n    --address=127.0.0.1 \n    --bind-address=127.0.0.1                                              # 1.4.2\n    --kubeconfig=/var/lib/rancher/k3s/server/cred/scheduler.kubeconfig \n    --port=10251 \n    --profiling=false                                                     # 1.4.1\n    --secure-port=0\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kubelet \n    --address=0.0.0.0 \n    --anonymous-auth=false                                                # 4.2.1\n    --authentication-token-webhook=true \n    --authorization-mode=Webhook                                          # 4.2.2\n    --cgroup-driver=cgroupfs \n    --client-ca-file=/var/lib/rancher/k3s/agent/client-ca.crt             # 4.2.3\n    --cloud-provider=external \n    --cluster-dns=10.43.0.10 \n    --cluster-domain=cluster.local \n    --cni-bin-dir=/var/lib/rancher/k3s/data/223e6420f8db0d8828a8f5ed3c44489bb8eb47aa71485404f8af8c462a29bea3/bin \n    --cni-conf-dir=/var/lib/rancher/k3s/agent/etc/cni/net.d \n    --container-runtime-endpoint=/run/k3s/containerd/containerd.sock \n    --container-runtime=remote \n    --containerd=/run/k3s/containerd/containerd.sock \n    --eviction-hard=imagefs.available<5%,nodefs.available<5% \n    --eviction-minimum-reclaim=imagefs.available=10%,nodefs.available=10% \n    --fail-swap-on=false \n    --healthz-bind-address=127.0.0.1 \n    --hostname-override=hostname01 \n    --kubeconfig=/var/lib/rancher/k3s/agent/kubelet.kubeconfig \n    --kubelet-cgroups=/systemd/system.slice \n    --node-labels= \n    --pod-manifest-path=/var/lib/rancher/k3s/agent/pod-manifests \n    --protect-kernel-defaults=true                                        # 4.2.6\n    --read-only-port=0                                                    # 4.2.4\n    --resolv-conf=/run/systemd/resolve/resolv.conf \n    --runtime-cgroups=/systemd/system.slice \n    --serialize-image-pulls=false \n    --tls-cert-file=/var/lib/rancher/k3s/agent/serving-kubelet.crt        # 4.2.10\n    --tls-private-key-file=/var/lib/rancher/k3s/agent/serving-kubelet.key # 4.2.10\n")),(0,i.kt)("p",null,"The command below is an example of how the outlined remediations can be applied to harden K3s."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"k3s server \\\n    --protect-kernel-defaults=true \\\n    --secrets-encryption=true \\\n    --kube-apiserver-arg='audit-log-path=/var/lib/rancher/k3s/server/logs/audit.log' \\\n    --kube-apiserver-arg='audit-policy-file=/var/lib/rancher/k3s/server/audit.yaml' \\\n    --kube-apiserver-arg='audit-log-maxage=30' \\\n    --kube-apiserver-arg='audit-log-maxbackup=10' \\\n    --kube-apiserver-arg='audit-log-maxsize=100' \\\n    --kube-apiserver-arg='request-timeout=300s' \\\n    --kube-apiserver-arg='service-account-lookup=true' \\\n    --kube-apiserver-arg='enable-admission-plugins=NodeRestriction,PodSecurityPolicy,NamespaceLifecycle,ServiceAccount' \\\n    --kube-controller-manager-arg='terminated-pod-gc-threshold=10' \\\n    --kube-controller-manager-arg='use-service-account-credentials=true' \\\n    --kubelet-arg='streaming-connection-idle-timeout=5m' \\\n    --kubelet-arg='make-iptables-util-chains=true'\n")),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"If you have followed this guide, your K3s cluster will be configured to comply with the CIS Kubernetes Benchmark. You can review the ",(0,i.kt)("a",{parentName:"p",href:"/security/self-assessment"},"CIS Benchmark Self-Assessment Guide")," to understand the expectations of each of the benchmark's checks and how you can do the same on your cluster."))}m.isMDXComponent=!0}}]);